"use strict";
//--------------------------------------
//  Shallow update
//--------------------------------------
exports.__esModule = true;
/** Performs a shallow update of an object using a partial object of the same shape. A new object is returned. */
function update(host, spec) {
    var result = clone(host);
    for (var key in spec) {
        var specValue = spec[key];
        if (specValue === exports.DELETE) {
            delete result[key];
        }
        else {
            result[key] = specValue;
        }
    }
    return result;
}
exports.update = update;
// We lie about the public type so that only a property that is optional or that can be assigned to undefined can be DELETE'd
/** Marker used to delete a key */
exports.DELETE = {};
var _Updater = (function () {
    function _Updater(data) {
        this.data = data;
    }
    _Updater.prototype.at = function (keyOrIndex) {
        return new _Updater({ type: 'at', parent: this, field: keyOrIndex });
    };
    _Updater.prototype.set = function (value) {
        var _this = this;
        var doSet = function (target) {
            var _a = _this.cloneForUpdate(target), clonedTarget = _a[0], leafHost = _a[1], field = _a[2], aborted = _a[3];
            if (aborted)
                return target;
            leafHost[field] = value;
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doSet(boundTarget)
            : doSet;
    };
    _Updater.prototype.modify = function (modifier) {
        var _this = this;
        var doModify = function (target) {
            var _a = _this.cloneForUpdate(target), clonedTarget = _a[0], leafHost = _a[1], field = _a[2], aborted = _a[3];
            if (aborted)
                return target;
            leafHost[field] = modifier(leafHost[field]);
            return clonedTarget;
        };
        var boundTarget = this.findBoundTarget();
        return boundTarget
            ? doModify(boundTarget)
            : doModify;
    };
    _Updater.prototype.withDefault = function (value) {
        return new _Updater({ type: 'withDefault', parent: this, defaultValue: value });
    };
    _Updater.prototype.abortIfUndef = function () {
        return new _Updater({ type: 'abortIfUndef', parent: this });
    };
    _Updater.prototype.findBoundTarget = function () {
        var current = this;
        while (true) {
            if (current.data.type === 'root')
                return current.data.boundTarget;
            current = current.data.parent;
        }
    };
    _Updater.prototype.parentUpdaters = function () {
        var updaters = [this];
        var parentUpdater = this.data.parent;
        // Ignore the root updater
        while (parentUpdater && parentUpdater.data.parent) {
            updaters.unshift(parentUpdater);
            parentUpdater = parentUpdater.data.parent;
        }
        return updaters;
    };
    _Updater.prototype.cloneForUpdate = function (target) {
        var updaters = this.parentUpdaters();
        var obj = clone(target);
        var currentObj = obj;
        var lastObj = obj;
        for (var i = 0; i < updaters.length - 1; i++) {
            var data = updaters[i].data;
            var nextData = updaters[i + 1].data;
            if (data.type !== 'at')
                continue;
            var newObj = currentObj[data.field];
            if (newObj !== undefined)
                newObj = clone(newObj);
            else if (nextData.type === 'abortIfUndef')
                return [, , , true];
            else if (nextData.type === 'withDefault')
                newObj = nextData.defaultValue;
            lastObj = currentObj;
            currentObj = currentObj[data.field] = newObj;
        }
        var leafHost = this.data.type === 'at'
            ? currentObj
            : lastObj;
        var field = this.data.type === 'at'
            ? this.data.field
            : updaters[updaters.length - 2].data.field;
        return [obj, leafHost, field, false];
    };
    return _Updater;
}());
function clone(obj) {
    if (Array.isArray(obj))
        return obj.slice();
    var cloned = {};
    Object.keys(obj).forEach(function (key) { cloned[key] = obj[key]; });
    return cloned;
}
function deepUpdate(target) {
    return new _Updater({ type: 'root', boundTarget: target });
}
exports.deepUpdate = deepUpdate;
