/*
* Create a new Transition instance.
*/
function Transition(fromStateWithParams, toStateWithParams, paramsDiff, acc, router, logger) {
  var root = { root: null, inclusive: true };
  var enters = void 0;
  var exits = void 0;

  var fromState = fromStateWithParams && fromStateWithParams.state;
  var toState = toStateWithParams.state;
  var params = toStateWithParams.params;
  var isUpdate = fromState == toState;

  var transition = {
    from: fromState,
    to: toState,
    toParams: params,
    cancel: cancel,
    run: run,
    cancelled: false,
    currentState: fromState
  };

  // The first transition has no fromState.
  if (fromState) root = transitionRoot(fromState, toState, isUpdate, paramsDiff);

  exits = fromState ? transitionStates(fromState, root) : [];
  enters = transitionStates(toState, root).reverse();

  function run() {
    startTransition(enters, exits, params, transition, isUpdate, acc, router, logger);
  }

  function cancel() {
    transition.cancelled = true;
  }

  return transition;
}

function startTransition(enters, exits, params, transition, isUpdate, acc, router, logger) {
  acc = acc || {};

  transition.exiting = true;
  exits.forEach(function (state) {
    if (isUpdate && state.update) return;
    runStep(state, 'exit', params, transition, acc, router, logger);
  });
  transition.exiting = false;

  enters.forEach(function (state) {
    var fn = isUpdate && state.update ? 'update' : 'enter';
    runStep(state, fn, params, transition, acc, router, logger);
  });
}

function runStep(state, stepFn, params, transition, acc, router, logger) {
  if (transition.cancelled) return;

  if (logger.enabled) {
    var capitalizedStep = stepFn[0].toUpperCase() + stepFn.slice(1);
    logger.log(capitalizedStep + ' ' + state.fullName);
  }

  var result = state[stepFn](params, acc, router);

  if (transition.cancelled) return;

  transition.currentState = stepFn == 'exit' ? state.parent : state;

  return result;
}

/*
* The top-most fromState's parent that must be exited
* or undefined if the two states are in distinct branches of the tree.
*/
function transitionRoot(fromState, toState, isUpdate, paramsDiff) {
  var closestCommonParent = void 0;

  var parents = [fromState].concat(fromState.parents).reverse();

  // Find the closest common parent of the from/to states, if any.
  if (!isUpdate) {
    for (var i = 0; i < fromState.parents.length; i++) {
      var parent = fromState.parents[i];

      if (toState.parents.indexOf(parent) > -1) {
        closestCommonParent = parent;
        break;
      }
    }
  }

  // Find the top-most parent owning some updated param(s) or bail if we first reach the closestCommonParent
  for (var _i = 0; _i < parents.length; _i++) {
    var _parent = parents[_i];

    for (var param in paramsDiff.all) {
      if (_parent.params[param] || _parent.queryParams[param]) return { root: _parent, inclusive: true };
    }

    if (_parent === closestCommonParent) return { root: closestCommonParent, inclusive: false };
  }

  return closestCommonParent ? { root: closestCommonParent, inclusive: false } : { inclusive: true };
}

function transitionStates(state, _ref) {
  var root = _ref.root,
      inclusive = _ref.inclusive;

  root = root || state.root;

  var p = state.parents;
  var end = Math.min(p.length, p.indexOf(root) + (inclusive ? 1 : 0));

  return [state].concat(p.slice(0, end));
}

export default Transition;